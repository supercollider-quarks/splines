{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf0 	wrapxInterpolate \{ \cf2 arg\cf0  divisionsPerSegment=128;\
		\cf3 // odd: last point is far right edge\cf0 \
		\cf3 // if first point is at far left edge\cf0 \
		\cf3 // then they are at same time\cf0 \
		\cf3 // onscreen you expect to be viewing one cycle\cf0 \
		\cf3 // not have it varying in wavelength by where last point lies.\cf0 \
		\cf3 // maybe that is fine. no other way to vary the wavelength without zooming\cf0 \
		\cf2 var\cf0  first,ps,li,one,two;\
		first = \cf2 Point\cf0 (points.last.x + points.first.x,points.first.y);\
		ps = (points ++ [first]).collect(\cf2 _\cf0 .asArray)\
			.interpolate(divisionsPerSegment,\
						\cf2 this\cf0 .interpolationKey,\
						\cf2 false\cf0 ,order)\
			.collect(\cf2 _\cf0 .asPoint);\
		\cf3 // chop off after last point\cf0 \
		\cf3 // move to pre-first\cf0 \
		li = ps.lastIndexForWhich(\cf2 _\cf0 .x < points.last.x);\
		if(li.notNil,\{\
			one = ps.copyToEnd(li).collect(\{ \cf2 |p|\cf0  \cf2 Point\cf0 (p.x-points.last.x,p.y) \});\
			two = ps.copyRange(0,li-1);\
			ps = one ++ two\
		\});\
		^ps\
	\}\
	\
	interpolateAlongX \{ \cf2 arg\cf0  divisions,totalTime,fillEnds=\cf2 true\cf0 ;\
		\cf3 // return y values where x is divided evenly (eg. steady time increments)\cf0 \
		\cf3 // interpolate returns a series of points evenly spaced along the spline path\cf0 \
		\cf3 // but not evenly spaced for X\cf0 \
\
		\cf3 // doesn't do loop correctly yet\cf0 \
		\cf2 var\cf0  ps,step,feed,t=0.0;\
		if(loop,\{\
			ps = \cf2 this\cf0 .wrapxInterpolate(divisions / points.size * 4.0)\
		\},\{\
			ps = \cf2 this\cf0 .interpolate(divisions / points.size * 4.0); \cf3 // oversampled\cf0 \
		\});\
				\
		if(totalTime.isNil, \{\
			totalTime = ps.last.x;\
		\});\
		step = totalTime / divisions;\
		feed = \cf2 Routine\cf0 (\{\
				\cf2 var\cf0  xfrac,after;\
				ps.do(\{ \cf2 arg\cf0  p,i;\
					\cf3 //[t,p,i].debug;\cf0 \
					if(t == p.x, \{\
						p.y.yield\
					\});\
					while(\{ p.x > t \},\{\
						if(i > 0,\{\
							xfrac = (t - ps[i-1].x) / (p.x - ps[i-1].x);\
							blend(ps[i-1].y,p.y,xfrac).yield\
						\},\{\
							\cf3 // point is already past t\cf0 \
							\cf3 // if loop then interpolate with last point wrapped with totalTime\cf0 \
							\cf3 // else either nil or fill with first value (waiting for spline to start)\cf0 \
							if(fillEnds,\{\
								p.y.yield\
							\},\{\
								\cf2 nil\cf0 .yield\
							\})\
						\})\
					\})\
				\});\
				\cf2 inf\cf0 .do(\{\
					if(fillEnds,\{\
						ps.last.y.yield\
					\},\{\
						\cf2 nil\cf0 .yield\
					\})\
				\})\
			\});\
							\
		^\cf2 Array\cf0 .fill(divisions,\{ \cf2 |i|\cf0 \
			t = i * step;\
			feed.next\
		\})\
	\}\
	\
	kr \{ \cf2 arg\cf0  timeScale=1.0,doneAction=0,divisions=512;\
	    \cf3 // spline x values are seconds\cf0 \
	    \cf3 // if timeScale is tempo then x values are beats\cf0 \
		\cf2 var\cf0  b,index,levels;\
		levels = \cf2 this\cf0 .interpolateAlongX(divisions);\
		b = \cf2 LocalBuf\cf0 .newFrom(levels);\
		if(loop,\{\
			index = \cf2 VarSaw\cf0 .kr(\cf2 this\cf0 .duration.reciprocal * timeScale,width:1).range(0,levels.size-1)\
		\},\{\
			index = \cf2 Line\cf0 .kr(0.0,levels.size-1,\cf2 this\cf0 .duration * timeScale,doneAction:doneAction);\
		\});\
		^\cf2 BufRd\cf0 .kr(1,b,index,loop,4)\
	\}\
	readKr \{ \cf2 arg\cf0  position,timeScale=1.0,divisions=512;\
	    \cf3 // position is in X units (seconds)\cf0 \
	    \cf3 // if timeScale is tempo then x values are beats\cf0 \
		\cf2 var\cf0  b,index,levels;\
		levels = \cf2 this\cf0 .interpolateAlongX(divisions);\
		b = \cf2 LocalBuf\cf0 .newFrom(levels);\
		if(timeScale != 1.0,\{\
		    position = position * timeScale;\
		\});\
		index = (position / \cf2 this\cf0 .duration) * divisions;\
		^\cf2 BufRd\cf0 .kr(1,b,index,loop,4)\
	\}	\
	ar \{ \cf2 arg\cf0  freq=440,phase=0,divisions=1024;\
	    \cf3 // plays in cycles (full spline) per second\cf0 \
		\cf2 var\cf0  b,index,totalTime=0,levels;\
		levels = \cf2 this\cf0 .interpolateAlongX(divisions);\
		totalTime = \cf2 this\cf0 .points.last.x;\
		b = \cf2 LocalBuf\cf0 .newFrom(levels);\
		if(loop,\{\
			index = \cf2 VarSaw\cf0 .ar((totalTime).reciprocal * freq,phase,width:1).range(0,levels.size-1)\
		\},\{\
			index = \cf2 Line\cf0 .ar(phase / 2pi * (levels.size-1),levels.size-1,totalTime * freq);\
		\});\
		^\cf2 BufRd\cf0 .ar(1,b,index,loop,4)\
	\}\
\
\
}